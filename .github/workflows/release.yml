name: Build & Release - Multi-Platform (Nuitka Compiled)

on:
  push:
    branches:
      - main
    tags:
      - "v*.*.*"
  workflow_dispatch:

env:
  PYTHON_VERSION: "3.12"
  APP_NAME: "OA-OrientationAutomator"

jobs:
  security-audit:
    name: Security Audit
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install audit tools
        run: |
          python -m pip install --upgrade pip
          pip install pip-audit safety

      - name: Run pip-audit (requirements files)
        run: |
          if [ -f "requirements.txt" ]; then
            pip-audit --requirement requirements.txt --desc
          else
            echo "⚠️ requirements.txt not found, skipping"
          fi

          if [ -f "requirements-security.txt" ]; then
            pip-audit --requirement requirements-security.txt --desc
          else
            echo "⚠️ requirements-security.txt not found, skipping"
          fi

      - name: Run safety check (warning only)
        run: |
          safety check --json
        continue-on-error: true

      - name: Verify no hardcoded secrets
        run: |
          echo "Scanning for hardcoded secrets..."

          if grep -r "sk-[a-zA-Z0-9]" src/ 2>/dev/null; then
            echo "ERROR: Potential hardcoded OpenAI-style API key found!"
            exit 1
          fi

          if grep -r "api_key.*=.*['\"][^'\"]\+" src/ 2>/dev/null | \
             grep -v "os\.getenv" | \
             grep -v "os\.environ" | \
             grep -v "config\.get" | \
             grep -v "\.get(" | \
             grep -v "api_key.*=.*['\"]['\"]" | \
             grep -q .; then
            echo "ERROR: Hardcoded API key found!"
            echo "Found:"
            grep -r "api_key.*=.*['\"][^'\"]\+" src/ | \
              grep -v "os\.getenv" | \
              grep -v "os\.environ" | \
              grep -v "config\.get" | \
              grep -v "\.get(" | \
              grep -v "api_key.*=.*['\"]['\"]"
            exit 1
          fi

          echo "✓ No hardcoded secrets found"

  build-compiled:
    name: Build ${{ matrix.os }}
    needs: security-audit
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [windows-latest, macos-latest, ubuntu-latest]
        include:
          - os: windows-latest
            binary_name: OA-OrientationAutomator.exe
            artifact_name: windows-x64
          - os: macos-latest
            binary_name: OA-OrientationAutomator
            artifact_name: macos
          - os: ubuntu-latest
            binary_name: OA-OrientationAutomator
            artifact_name: linux-x64

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install uv (fast dependency manager)
        run: |
          python -m pip install --upgrade pip
          pip install uv
        shell: bash

      - name: Install dependencies with uv
        run: |
          if [ -f "requirements.txt" ]; then
            uv pip install --system -r requirements.txt
          else
            echo "⚠️ requirements.txt not found, installing common deps"
            uv pip install --system PySide6 requests platformdirs python-dotenv cryptography
          fi

          if [ -f "requirements-security.txt" ]; then
            uv pip install --system -r requirements-security.txt
          fi
        shell: bash

      - name: Install Nuitka
        run: |
          # You said you use 2.8.9; keep it explicit so CI is deterministic.
          pip install "nuitka==2.8.9" ordered-set zstandard
          python -m nuitka --version
        shell: bash

      - name: Install Platform-Specific Build Tools
        run: |
          if [ "${{ matrix.os }}" == "ubuntu-latest" ]; then
            sudo apt-get update
            sudo apt-get install -y ccache patchelf
          elif [ "${{ matrix.os }}" == "macos-latest" ]; then
            brew install ccache
          fi
        shell: bash

      - name: Create build metadata
        run: |
          echo "Build Date: $(date -u +'%Y-%m-%d %H:%M:%S UTC')" > BUILD_INFO.txt
          echo "Platform: ${{ matrix.os }}" >> BUILD_INFO.txt
          echo "Python: ${{ env.PYTHON_VERSION }}" >> BUILD_INFO.txt
          echo "Commit: ${{ github.sha }}" >> BUILD_INFO.txt
          echo "Branch: ${{ github.ref_name }}" >> BUILD_INFO.txt
        shell: bash

      - name: Compile with Nuitka (GUI)
        run: |
          echo "Starting Nuitka compilation..."

          NUITKA_EXTRA=""

          if [ "${{ matrix.os }}" == "windows-latest" ]; then
            NUITKA_EXTRA="--windows-console-mode=disable"
            if [ -f "assets/icon.ico" ]; then
              NUITKA_EXTRA="$NUITKA_EXTRA --windows-icon-from-ico=assets/icon.ico"
              echo "✓ Windows icon: assets/icon.ico"
            else
              echo "⚠️ assets/icon.ico not found, skipping Windows icon"
            fi

          elif [ "${{ matrix.os }}" == "macos-latest" ]; then
            # IMPORTANT: macOS icon works properly when you build a .app bundle.
            if [ -f "assets/icon.png" ]; then
              NUITKA_EXTRA="--macos-app-icon=assets/icon.png"
              echo "✓ macOS icon: assets/icon.png"
            elif [ -f "assets/icon.icns" ]; then
              NUITKA_EXTRA="--macos-app-icon=assets/icon.icns"
              echo "✓ macOS icon: assets/icon.icns"
            else
              echo "⚠️ No macOS icon found (assets/icon.png or assets/icon.icns), skipping"
            fi

          else
            # Linux icon is mostly for desktop integration; harmless if present.
            if [ -f "assets/icon.png" ]; then
              NUITKA_EXTRA="--linux-icon=assets/icon.png"
              echo "✓ Linux icon: assets/icon.png"
            else
              echo "⚠️ assets/icon.png not found, skipping Linux icon"
            fi
          fi

          # macOS: build app bundle (no --onefile) so icon works in Finder/Dock
          if [ "${{ matrix.os }}" == "macos-latest" ]; then
            python -m nuitka \
              --standalone \
              --macos-create-app-bundle \
              --enable-plugin=pyside6 \
              --include-package=src \
              --include-package=dotenv \
              --include-package=platformdirs \
              --include-data-files=config.json=config.json \
              --include-data-files=env.example=env.example \
              --noinclude-pytest-mode=nofollow \
              --noinclude-setuptools-mode=nofollow \
              --assume-yes-for-downloads \
              --output-dir=dist \
              --output-filename="${{ matrix.binary_name }}" \
              $NUITKA_EXTRA \
              gui_new.py
          else
            # Windows + Linux: keep onefile
            python -m nuitka \
              --standalone \
              --onefile \
              --enable-plugin=pyside6 \
              --include-package=src \
              --include-package=dotenv \
              --include-package=platformdirs \
              --include-data-files=config.json=config.json \
              --include-data-files=env.example=env.example \
              --noinclude-pytest-mode=nofollow \
              --noinclude-setuptools-mode=nofollow \
              --assume-yes-for-downloads \
              --output-dir=dist \
              --output-filename="${{ matrix.binary_name }}" \
              $NUITKA_EXTRA \
              gui_new.py
          fi

          echo "✓ Nuitka compilation complete"
        shell: bash

      - name: Verify compilation
        id: verify-binary
        run: |
          echo "Verifying build outputs..."
          ls -lah dist/ || true

          if [ "${{ matrix.os }}" == "windows-latest" ]; then
            BINARY_PATH="dist/${{ matrix.binary_name }}"
          elif [ "${{ matrix.os }}" == "macos-latest" ]; then
            BINARY_PATH="dist/${{ matrix.binary_name }}.app"
          else
            BINARY_PATH="dist/${{ matrix.binary_name }}"
          fi

          if [ -e "$BINARY_PATH" ]; then
            echo "✓ Output created: $BINARY_PATH"
            echo "binary_path=$BINARY_PATH" >> $GITHUB_OUTPUT
          else
            echo "ERROR: Expected output not found: $BINARY_PATH"
            echo "Dist contents:"
            find dist -maxdepth 3 -print || true
            exit 1
          fi

          # macOS sanity check: confirm icon keys exist (best-effort)
          if [ "${{ matrix.os }}" == "macos-latest" ]; then
            echo "macOS bundle check:"
            ls -lah "dist/${{ matrix.binary_name }}.app/Contents" || true
            ls -lah "dist/${{ matrix.binary_name }}.app/Contents/Resources" || true
            plutil -p "dist/${{ matrix.binary_name }}.app/Contents/Info.plist" | grep -i -E "CFBundleIcon|Icon" || true
          fi
        shell: bash

      - name: Create distribution package
        run: |
          echo "Creating distribution package..."
          mkdir -p release/${{ matrix.artifact_name }}

          # Copy build output
          if [ "${{ matrix.os }}" == "macos-latest" ]; then
            cp -R "dist/${{ matrix.binary_name }}.app" "release/${{ matrix.artifact_name }}/"
          else
            cp "dist/${{ matrix.binary_name }}" "release/${{ matrix.artifact_name }}/"
          fi

          # Copy docs/config
          cp BUILD_INFO.txt release/${{ matrix.artifact_name }}/
          cp README*.md release/${{ matrix.artifact_name }}/ 2>/dev/null || true
          cp SECURITY*.md release/${{ matrix.artifact_name }}/ 2>/dev/null || true
          cp env.example release/${{ matrix.artifact_name }}/ 2>/dev/null || true

          # Create README for distribution
          cat > release/${{ matrix.artifact_name }}/README.txt << 'EOF'
          OA - Orientation Automator
          ===========================

          This is a compiled binary distribution (Nuitka).

          USAGE:
          1. Copy env.example to .env
          2. Edit .env with your API keys (if needed)
          3. Run the app/binary

          NOTES:
          - macOS ships as a .app bundle (for proper app icon + Finder/Dock behavior)
          - Windows/Linux ship as single-file binaries
          EOF

          # Create archives
          if [ "${{ matrix.os }}" == "windows-latest" ]; then
            cd release
            7z a -tzip "${{ matrix.artifact_name }}.zip" "${{ matrix.artifact_name }}/"
            cd ..
          elif [ "${{ matrix.os }}" == "macos-latest" ]; then
            # Zip the .app properly so bundle metadata survives downloads
            cd release/${{ matrix.artifact_name }}
            ditto -c -k --sequesterRsrc --keepParent "${{ matrix.binary_name }}.app" "../${{ matrix.artifact_name }}.zip"
            cd - >/dev/null
          else
            cd release
            tar -czf "${{ matrix.artifact_name }}.tar.gz" "${{ matrix.artifact_name }}/"
            cd ..
          fi

          echo "✓ Distribution package created"
        shell: bash

      - name: Generate checksums
        run: |
          cd release
          if [ "${{ matrix.os }}" == "windows-latest" ]; then
            certutil -hashfile "${{ matrix.artifact_name }}.zip" SHA256 > "${{ matrix.artifact_name }}.zip.sha256"
          elif [ "${{ matrix.os }}" == "macos-latest" ]; then
            shasum -a 256 "${{ matrix.artifact_name }}.zip" > "${{ matrix.artifact_name }}.zip.sha256"
          else
            shasum -a 256 "${{ matrix.artifact_name }}.tar.gz" > "${{ matrix.artifact_name }}.tar.gz.sha256"
          fi
          cd ..
        shell: bash

      - name: Upload build output artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.artifact_name }}-output
          path: ${{ steps.verify-binary.outputs.binary_path }}
          if-no-files-found: error

      - name: Upload distribution package artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.artifact_name }}-package
          path: |
            release/${{ matrix.artifact_name }}.zip
            release/${{ matrix.artifact_name }}.zip.sha256
            release/${{ matrix.artifact_name }}.tar.gz
            release/${{ matrix.artifact_name }}.tar.gz.sha256
          if-no-files-found: warn

      - name: Upload to GitHub Release (on tag)
        if: startsWith(github.ref, 'refs/tags/')
        uses: softprops/action-gh-release@v1
        with:
          files: |
            release/${{ matrix.artifact_name }}.zip
            release/${{ matrix.artifact_name }}.zip.sha256
            release/${{ matrix.artifact_name }}.tar.gz
            release/${{ matrix.artifact_name }}.tar.gz.sha256
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  create-release-notes:
    name: Create Release Notes
    needs: build-compiled
    if: startsWith(github.ref, 'refs/tags/')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Generate release notes
        run: |
          cat > RELEASE_NOTES.md << 'EOF'
          # OA - Orientation Automator Release

          ## Security Features
          - ✅ Compiled with Nuitka (Python → C → machine code)
          - ✅ Standalone builds (no Python required)
          - ✅ Dependencies bundled
          - ✅ Basic dependency audits in CI

          ## Platforms
          - Windows x64 (single-file .exe)
          - macOS (.app bundle packaged as .zip for proper icon behavior)
          - Linux x64 (single-file binary)

          ## Installation
          1. Download the package for your platform
          2. Extract it
          3. Copy `env.example` to `.env` and configure
          4. Run the app/binary

          ## Checksums
          Verify your download with the included `.sha256` files.
          EOF

          cat RELEASE_NOTES.md

      - name: Update release with notes
        uses: softprops/action-gh-release@v1
        with:
          body_path: RELEASE_NOTES.md
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
